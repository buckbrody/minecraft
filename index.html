<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <!-- iOS full-screen web app -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Minecraft">
    <!-- Android full-screen web app -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#87CEEB">
    <title>Simple Minecraft Clone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #87CEEB;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        canvas {
            display: block;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            mix-blend-mode: difference;
        }
        #crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        #crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
        #hotbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 3px;
            z-index: 100;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 95vw;
        }
        .hotbar-slot {
            width: 44px;
            height: 44px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #555;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-family: monospace;
            font-size: 10px;
            cursor: pointer;
        }
        .hotbar-slot.selected {
            border-color: white;
            background: rgba(255, 255, 255, 0.3);
        }
        .block-preview {
            width: 32px;
            height: 32px;
            image-rendering: pixelated;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px black;
        }
        #instructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            font-family: Arial, sans-serif;
            z-index: 200;
        }
        #instructions h1 {
            margin-bottom: 20px;
            color: #4CAF50;
        }
        #instructions p {
            margin: 10px 0;
            line-height: 1.6;
        }
        #instructions .key {
            background: #333;
            padding: 2px 8px;
            border-radius: 3px;
            border: 1px solid #555;
        }
        #instructions.hidden {
            display: none;
        }
        .desktop-only {
            display: block;
        }
        .touch-only {
            display: none;
        }

        /* Touch Controls */
        #touch-controls {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 150;
        }
        #touch-controls.active {
            display: block;
        }

        /* Virtual Joystick */
        #joystick-zone {
            position: absolute;
            left: 0;
            bottom: 0;
            width: 40%;
            height: 50%;
            pointer-events: auto;
        }
        #joystick-base {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.2);
            border: 3px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: none;
        }
        #joystick-stick {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }

        /* Look Zone (right side of screen for camera control) */
        #look-zone {
            position: absolute;
            right: 0;
            top: 0;
            width: 60%;
            height: 70%;
            pointer-events: auto;
        }

        /* Action Buttons */
        #action-buttons {
            position: absolute;
            right: 20px;
            bottom: 100px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }
        .action-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.6);
            background: rgba(0, 0, 0, 0.4);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        .action-btn:active {
            background: rgba(255, 255, 255, 0.3);
        }
        #break-btn {
            background: rgba(200, 50, 50, 0.5);
        }
        #place-btn {
            background: rgba(50, 150, 50, 0.5);
        }

        /* Pause Button */
        #pause-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 44px;
            height: 44px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.6);
            background: rgba(0, 0, 0, 0.4);
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
        }
        #pause-btn:active {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Jump Button */
        #jump-btn {
            position: absolute;
            right: 110px;
            bottom: 100px;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.6);
            background: rgba(100, 100, 200, 0.5);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
        }
        #jump-btn:active {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Touch-friendly hotbar */
        body.touch-device .hotbar-slot {
            width: 48px;
            height: 48px;
            min-width: 44px;
            min-height: 44px;
        }
        body.touch-device #hotbar {
            bottom: 15px;
            gap: 4px;
            max-width: 98vw;
        }
        body.touch-device .block-preview {
            width: 36px;
            height: 36px;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="hotbar"></div>
    <div id="instructions">
        <h1>Minecraft Clone</h1>
        <p class="touch-only">Tap to start playing</p>
        <p class="desktop-only">Click to start playing</p>
        <div class="desktop-only">
            <p><span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span> - Move</p>
            <p><span class="key">Space</span> - Jump</p>
            <p><span class="key">Mouse</span> - Look around</p>
            <p><span class="key">E</span> or <span class="key">Left Click</span> - Break block</p>
            <p><span class="key">Q</span> or <span class="key">Right Click</span> - Place block</p>
            <p><span class="key">1-9, 0</span> or <span class="key">Scroll</span> - Select block</p>
        </div>
        <div class="touch-only">
            <p>Left side - Move joystick</p>
            <p>Right side - Drag to look</p>
            <p>JUMP - Jump</p>
            <p>BREAK / PLACE - Interact with blocks</p>
            <p>Tap hotbar - Select block</p>
        </div>
    </div>

    <!-- Touch Controls -->
    <div id="touch-controls">
        <div id="joystick-zone">
            <div id="joystick-base"></div>
            <div id="joystick-stick"></div>
        </div>
        <div id="look-zone"></div>
        <div id="action-buttons">
            <button id="break-btn" class="action-btn">BREAK</button>
            <button id="place-btn" class="action-btn">PLACE</button>
        </div>
        <button id="jump-btn">JUMP</button>
        <button id="pause-btn">| |</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Block types
        const BLOCKS = {
            AIR: 0,
            GRASS: 1,
            DIRT: 2,
            STONE: 3,
            WOOD: 4,
            LEAVES: 5,
            SAND: 6,
            JEB: 7,
            WWB: 8,
            FBB: 9,
            BENGALS: 10,
            SKYLINE: 11
        };

        const BLOCK_COLORS = {
            [BLOCKS.GRASS]: { top: 0x7CFC00, side: 0x8B4513, bottom: 0x8B4513 },
            [BLOCKS.DIRT]: { top: 0x8B4513, side: 0x8B4513, bottom: 0x8B4513 },
            [BLOCKS.STONE]: { top: 0x808080, side: 0x808080, bottom: 0x808080 },
            [BLOCKS.WOOD]: { top: 0xDEB887, side: 0x8B4513, bottom: 0xDEB887 },
            [BLOCKS.LEAVES]: { top: 0x228B22, side: 0x228B22, bottom: 0x228B22 },
            [BLOCKS.SAND]: { top: 0xF4A460, side: 0xF4A460, bottom: 0xF4A460 },
            [BLOCKS.JEB]: { top: 0x4169E1, side: 0x4169E1, bottom: 0x4169E1 },
            [BLOCKS.WWB]: { top: 0x32CD32, side: 0x32CD32, bottom: 0x32CD32 },
            [BLOCKS.FBB]: { top: 0xFF6347, side: 0xFF6347, bottom: 0xFF6347 },
            [BLOCKS.BENGALS]: { top: 0xFB4F14, side: 0x000000, bottom: 0xFB4F14 },
            [BLOCKS.SKYLINE]: { top: 0x1C3A6E, side: 0x1C3A6E, bottom: 0x1C3A6E }
        };

        const BLOCK_NAMES = {
            [BLOCKS.GRASS]: 'Grass',
            [BLOCKS.DIRT]: 'Dirt',
            [BLOCKS.STONE]: 'Stone',
            [BLOCKS.WOOD]: 'Wood',
            [BLOCKS.LEAVES]: 'Leaves',
            [BLOCKS.SAND]: 'Sand',
            [BLOCKS.JEB]: 'JEB',
            [BLOCKS.WWB]: 'WWB',
            [BLOCKS.FBB]: 'FBB',
            [BLOCKS.BENGALS]: 'Bengals',
            [BLOCKS.SKYLINE]: 'Skyline'
        };

        // Custom textured blocks registry
        const TEXTURED_BLOCKS = new Set([BLOCKS.JEB, BLOCKS.WWB, BLOCKS.FBB, BLOCKS.BENGALS, BLOCKS.SKYLINE]);
        const blockTextures = {};

        // Create canvas texture for custom blocks
        function createBlockTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            if (type === BLOCKS.JEB) {
                // Blue block with "JEB" initials
                ctx.fillStyle = '#4169E1';
                ctx.fillRect(0, 0, 64, 64);
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('JEB', 32, 32);
                // Add a border
                ctx.strokeStyle = '#1E3A8A';
                ctx.lineWidth = 4;
                ctx.strokeRect(2, 2, 60, 60);
            }
            else if (type === BLOCKS.WWB) {
                // Green block with "WWB" initials
                ctx.fillStyle = '#32CD32';
                ctx.fillRect(0, 0, 64, 64);
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 22px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('WWB', 32, 32);
                ctx.strokeStyle = '#166534';
                ctx.lineWidth = 4;
                ctx.strokeRect(2, 2, 60, 60);
            }
            else if (type === BLOCKS.FBB) {
                // Red/coral block with "FBB" initials
                ctx.fillStyle = '#FF6347';
                ctx.fillRect(0, 0, 64, 64);
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('FBB', 32, 32);
                ctx.strokeStyle = '#B91C1C';
                ctx.lineWidth = 4;
                ctx.strokeRect(2, 2, 60, 60);
            }
            else if (type === BLOCKS.BENGALS) {
                // Cincinnati Bengals - Orange with black tiger stripes and "B" logo
                ctx.fillStyle = '#FB4F14'; // Bengals orange
                ctx.fillRect(0, 0, 64, 64);

                // Draw tiger stripes
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 6;
                ctx.beginPath();
                // Diagonal stripes like tiger pattern
                ctx.moveTo(0, 20); ctx.lineTo(20, 0);
                ctx.moveTo(0, 44); ctx.lineTo(44, 0);
                ctx.moveTo(20, 64); ctx.lineTo(64, 20);
                ctx.moveTo(44, 64); ctx.lineTo(64, 44);
                ctx.stroke();

                // Draw the "B" in the center
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 36px Georgia';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('B', 32, 34);

                // White outline on B
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1;
                ctx.strokeText('B', 32, 34);
            }
            else if (type === BLOCKS.SKYLINE) {
                // Skyline Chili - Blue background with skyline silhouette and text
                ctx.fillStyle = '#1C3A6E'; // Skyline blue
                ctx.fillRect(0, 0, 64, 64);

                // Draw city skyline silhouette at bottom
                ctx.fillStyle = '#D4A574'; // Tan/gold color
                // Buildings
                ctx.fillRect(4, 40, 8, 24);   // building 1
                ctx.fillRect(14, 34, 10, 30); // building 2 (taller)
                ctx.fillRect(26, 42, 8, 22);  // building 3
                ctx.fillRect(36, 30, 12, 34); // building 4 (tallest)
                ctx.fillRect(50, 38, 10, 26); // building 5

                // "SKYLINE" text
                ctx.fillStyle = '#D4A574';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('SKYLINE', 32, 14);

                // Small "CHILI" text below
                ctx.font = 'bold 9px Arial';
                ctx.fillText('CHILI', 32, 25);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        // Initialize textures
        function initBlockTextures() {
            for (const type of TEXTURED_BLOCKS) {
                blockTextures[type] = createBlockTexture(type);
            }
        }

        // World settings
        const WORLD_SIZE = 64;
        const WORLD_HEIGHT = 32;
        const CHUNK_SIZE = 16;

        // Game state
        let scene, camera, renderer;
        let world = new Map();
        let meshes = new Map();
        let selectedBlock = BLOCKS.GRASS;
        let isPointerLocked = false;

        // Player state
        const player = {
            position: new THREE.Vector3(WORLD_SIZE / 2, 20, WORLD_SIZE / 2),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: { x: 0, y: 0 },
            onGround: false
        };

        // Controls
        const keys = {};
        const GRAVITY = -0.015;
        const JUMP_FORCE = 0.25;
        const MOVE_SPEED = 0.12;
        const MOUSE_SENSITIVITY = 0.002;

        // Touch controls state
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        let touchActive = false;
        const touchState = {
            joystick: {
                active: false,
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                identifier: null
            },
            look: {
                active: false,
                lastX: 0,
                lastY: 0,
                identifier: null
            },
            jump: false,
            moveDirection: { x: 0, z: 0 }
        };
        const TOUCH_SENSITIVITY = 0.004;
        const JOYSTICK_MAX_DISTANCE = 50;

        // Simplex noise implementation
        class SimplexNoise {
            constructor(seed = Math.random()) {
                this.p = new Uint8Array(256);
                for (let i = 0; i < 256; i++) this.p[i] = i;
                for (let i = 255; i > 0; i--) {
                    seed = (seed * 16807) % 2147483647;
                    const j = seed % (i + 1);
                    [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
                }
                this.perm = new Uint8Array(512);
                for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];
            }

            noise2D(x, y) {
                const F2 = 0.5 * (Math.sqrt(3) - 1);
                const G2 = (3 - Math.sqrt(3)) / 6;

                const s = (x + y) * F2;
                const i = Math.floor(x + s);
                const j = Math.floor(y + s);

                const t = (i + j) * G2;
                const X0 = i - t;
                const Y0 = j - t;
                const x0 = x - X0;
                const y0 = y - Y0;

                const i1 = x0 > y0 ? 1 : 0;
                const j1 = x0 > y0 ? 0 : 1;

                const x1 = x0 - i1 + G2;
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1 + 2 * G2;
                const y2 = y0 - 1 + 2 * G2;

                const ii = i & 255;
                const jj = j & 255;

                const grad = (hash, x, y) => {
                    const h = hash & 7;
                    const u = h < 4 ? x : y;
                    const v = h < 4 ? y : x;
                    return ((h & 1) ? -u : u) + ((h & 2) ? -2 * v : 2 * v);
                };

                let n0 = 0, n1 = 0, n2 = 0;
                let t0 = 0.5 - x0 * x0 - y0 * y0;
                if (t0 >= 0) {
                    t0 *= t0;
                    n0 = t0 * t0 * grad(this.perm[ii + this.perm[jj]], x0, y0);
                }

                let t1 = 0.5 - x1 * x1 - y1 * y1;
                if (t1 >= 0) {
                    t1 *= t1;
                    n1 = t1 * t1 * grad(this.perm[ii + i1 + this.perm[jj + j1]], x1, y1);
                }

                let t2 = 0.5 - x2 * x2 - y2 * y2;
                if (t2 >= 0) {
                    t2 *= t2;
                    n2 = t2 * t2 * grad(this.perm[ii + 1 + this.perm[jj + 1]], x2, y2);
                }

                return 70 * (n0 + n1 + n2);
            }
        }

        const noise = new SimplexNoise(12345);

        // Generate height at position
        function getHeight(x, z) {
            const scale1 = 0.02;
            const scale2 = 0.05;
            const scale3 = 0.1;

            const n1 = noise.noise2D(x * scale1, z * scale1) * 8;
            const n2 = noise.noise2D(x * scale2, z * scale2) * 4;
            const n3 = noise.noise2D(x * scale3, z * scale3) * 2;

            // Base height 12, ensure minimum of 4
            return Math.max(4, Math.floor(12 + n1 + n2 + n3));
        }

        // World management
        function getBlockKey(x, y, z) {
            return `${x},${y},${z}`;
        }

        function getBlock(x, y, z) {
            return world.get(getBlockKey(x, y, z)) || BLOCKS.AIR;
        }

        function setBlock(x, y, z, type) {
            const key = getBlockKey(x, y, z);
            if (type === BLOCKS.AIR) {
                world.delete(key);
                if (meshes.has(key)) {
                    scene.remove(meshes.get(key));
                    meshes.delete(key);
                }
            } else {
                world.set(key, type);
                createBlockMesh(x, y, z, type);
            }
            updateNeighborMeshes(x, y, z);
        }

        // Check if face is visible
        function isFaceVisible(x, y, z, dx, dy, dz) {
            return getBlock(x + dx, y + dy, z + dz) === BLOCKS.AIR;
        }

        // Create block mesh with only visible faces
        function createBlockMesh(x, y, z, type) {
            const key = getBlockKey(x, y, z);

            // Remove existing mesh
            if (meshes.has(key)) {
                scene.remove(meshes.get(key));
            }

            // For textured blocks, use a simple box with texture on all faces
            if (TEXTURED_BLOCKS.has(type)) {
                // Check if any face is visible
                const hasVisibleFace =
                    isFaceVisible(x, y, z, 0, 1, 0) || isFaceVisible(x, y, z, 0, -1, 0) ||
                    isFaceVisible(x, y, z, 0, 0, 1) || isFaceVisible(x, y, z, 0, 0, -1) ||
                    isFaceVisible(x, y, z, 1, 0, 0) || isFaceVisible(x, y, z, -1, 0, 0);

                if (!hasVisibleFace) return;

                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshLambertMaterial({
                    map: blockTextures[type]
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
                mesh.userData = { x, y, z, type };
                scene.add(mesh);
                meshes.set(key, mesh);
                return;
            }

            const colors = BLOCK_COLORS[type];
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const normals = [];
            const vertexColors = [];

            // Helper to add a face
            const addFace = (v1, v2, v3, v4, normal, color) => {
                vertices.push(...v1, ...v2, ...v3, ...v1, ...v3, ...v4);
                for (let i = 0; i < 6; i++) {
                    normals.push(...normal);
                    const c = new THREE.Color(color);
                    vertexColors.push(c.r, c.g, c.b);
                }
            };

            // Top face (+Y)
            if (isFaceVisible(x, y, z, 0, 1, 0)) {
                addFace(
                    [0, 1, 0], [0, 1, 1], [1, 1, 1], [1, 1, 0],
                    [0, 1, 0], colors.top
                );
            }

            // Bottom face (-Y)
            if (isFaceVisible(x, y, z, 0, -1, 0)) {
                addFace(
                    [0, 0, 1], [0, 0, 0], [1, 0, 0], [1, 0, 1],
                    [0, -1, 0], colors.bottom
                );
            }

            // Front face (+Z)
            if (isFaceVisible(x, y, z, 0, 0, 1)) {
                addFace(
                    [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1],
                    [0, 0, 1], colors.side
                );
            }

            // Back face (-Z)
            if (isFaceVisible(x, y, z, 0, 0, -1)) {
                addFace(
                    [1, 0, 0], [0, 0, 0], [0, 1, 0], [1, 1, 0],
                    [0, 0, -1], colors.side
                );
            }

            // Right face (+X)
            if (isFaceVisible(x, y, z, 1, 0, 0)) {
                addFace(
                    [1, 0, 1], [1, 0, 0], [1, 1, 0], [1, 1, 1],
                    [1, 0, 0], colors.side
                );
            }

            // Left face (-X)
            if (isFaceVisible(x, y, z, -1, 0, 0)) {
                addFace(
                    [0, 0, 0], [0, 0, 1], [0, 1, 1], [0, 1, 0],
                    [-1, 0, 0], colors.side
                );
            }

            if (vertices.length === 0) return;

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColors, 3));

            const material = new THREE.MeshLambertMaterial({
                vertexColors: true,
                transparent: type === BLOCKS.LEAVES,
                opacity: type === BLOCKS.LEAVES ? 0.9 : 1
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.userData = { x, y, z, type };

            scene.add(mesh);
            meshes.set(key, mesh);
        }

        // Update neighboring block meshes
        function updateNeighborMeshes(x, y, z) {
            const neighbors = [
                [x+1, y, z], [x-1, y, z],
                [x, y+1, z], [x, y-1, z],
                [x, y, z+1], [x, y, z-1]
            ];

            for (const [nx, ny, nz] of neighbors) {
                const type = getBlock(nx, ny, nz);
                if (type !== BLOCKS.AIR) {
                    createBlockMesh(nx, ny, nz, type);
                }
            }
        }

        // Generate terrain
        function generateWorld() {
            for (let x = 0; x < WORLD_SIZE; x++) {
                for (let z = 0; z < WORLD_SIZE; z++) {
                    const height = getHeight(x, z);

                    for (let y = 0; y < height; y++) {
                        let blockType;
                        if (y === height - 1) {
                            blockType = BLOCKS.GRASS;
                        } else if (y > height - 4) {
                            blockType = BLOCKS.DIRT;
                        } else {
                            blockType = BLOCKS.STONE;
                        }
                        world.set(getBlockKey(x, y, z), blockType);
                    }
                }
            }

            // Generate trees
            for (let i = 0; i < 50; i++) {
                const tx = Math.floor(Math.random() * (WORLD_SIZE - 4)) + 2;
                const tz = Math.floor(Math.random() * (WORLD_SIZE - 4)) + 2;
                const ty = getHeight(tx, tz);

                if (getBlock(tx, ty - 1, tz) === BLOCKS.GRASS) {
                    generateTree(tx, ty, tz);
                }
            }

            // Create all meshes
            for (const [key, type] of world) {
                const [x, y, z] = key.split(',').map(Number);
                createBlockMesh(x, y, z, type);
            }
        }

        // Generate a tree
        function generateTree(x, y, z) {
            const height = 4 + Math.floor(Math.random() * 3);

            // Trunk
            for (let i = 0; i < height; i++) {
                world.set(getBlockKey(x, y + i, z), BLOCKS.WOOD);
            }

            // Leaves
            const leafStart = y + height - 2;
            for (let dy = 0; dy < 3; dy++) {
                const radius = dy === 2 ? 1 : 2;
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dz = -radius; dz <= radius; dz++) {
                        if (dx === 0 && dz === 0 && dy < 2) continue;
                        if (Math.abs(dx) === 2 && Math.abs(dz) === 2) continue;
                        const key = getBlockKey(x + dx, leafStart + dy, z + dz);
                        if (!world.has(key)) {
                            world.set(key, BLOCKS.LEAVES);
                        }
                    }
                }
            }
        }

        // Initialize Three.js
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 30, 80);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(player.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            // Initialize custom block textures
            initBlockTextures();

            // Generate world
            generateWorld();

            // Set player position above terrain
            const spawnHeight = getHeight(Math.floor(player.position.x), Math.floor(player.position.z));
            player.position.y = spawnHeight + 2;

            // Create hotbar
            createHotbar();

            // Event listeners
            setupEventListeners();

            // Setup touch controls (after hotbar exists)
            setupTouchControls();

            // Start game loop
            animate();
        }

        // Create hotbar UI
        function createHotbar() {
            const hotbar = document.getElementById('hotbar');
            const blockTypes = [BLOCKS.GRASS, BLOCKS.DIRT, BLOCKS.STONE, BLOCKS.WOOD, BLOCKS.LEAVES, BLOCKS.SAND, BLOCKS.JEB, BLOCKS.WWB, BLOCKS.FBB, BLOCKS.BENGALS, BLOCKS.SKYLINE];

            blockTypes.forEach((type, index) => {
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot' + (type === selectedBlock ? ' selected' : '');
                slot.dataset.block = type;

                const color = BLOCK_COLORS[type].top;
                const colorHex = color.toString(16).padStart(6, '0');
                const borderColor = Math.max(0, color - 0x202020).toString(16).padStart(6, '0');

                // Custom preview for special blocks
                let previewContent = '';
                if (type === BLOCKS.JEB) {
                    previewContent = '<span style="font-size:11px;font-weight:bold;">JEB</span>';
                } else if (type === BLOCKS.WWB) {
                    previewContent = '<span style="font-size:10px;font-weight:bold;">WWB</span>';
                } else if (type === BLOCKS.FBB) {
                    previewContent = '<span style="font-size:11px;font-weight:bold;">FBB</span>';
                } else if (type === BLOCKS.BENGALS) {
                    previewContent = '<span style="font-size:14px;font-weight:bold;color:#000;text-shadow:none;">B</span>';
                } else if (type === BLOCKS.SKYLINE) {
                    previewContent = '<span style="font-size:7px;font-weight:bold;color:#D4A574;">SKY</span>';
                }

                slot.innerHTML = `
                    <div class="block-preview" style="background: #${colorHex}; border: 2px solid #${borderColor}">${previewContent}</div>
                `;

                const keyHint = index < 9 ? index + 1 : (index === 9 ? '0' : '');
                slot.title = `${BLOCK_NAMES[type]}${keyHint ? ' (' + keyHint + ')' : ''}`;

                hotbar.appendChild(slot);
            });
        }

        // Update hotbar selection
        function updateHotbar() {
            document.querySelectorAll('.hotbar-slot').forEach(slot => {
                slot.classList.toggle('selected', parseInt(slot.dataset.block) === selectedBlock);
            });
        }

        // Setup event listeners
        function setupEventListeners() {
            // Pointer lock
            document.addEventListener('click', () => {
                if (!isPointerLocked) {
                    document.body.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === document.body;
                document.getElementById('instructions').classList.toggle('hidden', isPointerLocked);
            });

            // Mouse movement
            document.addEventListener('mousemove', (e) => {
                if (!isPointerLocked) return;

                player.rotation.y -= e.movementX * MOUSE_SENSITIVITY;
                player.rotation.x -= e.movementY * MOUSE_SENSITIVITY;
                player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.x));
            });

            // Mouse buttons
            document.addEventListener('mousedown', (e) => {
                if (!isPointerLocked) return;

                if (e.button === 0) {
                    breakBlock();
                } else if (e.button === 2) {
                    placeBlock();
                }
            });

            document.addEventListener('contextmenu', (e) => e.preventDefault());

            // Keyboard
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;

                // Number keys for block selection
                // Number keys 1-9 and 0 for block selection
                if (e.code >= 'Digit1' && e.code <= 'Digit9') {
                    const blockTypes = [BLOCKS.GRASS, BLOCKS.DIRT, BLOCKS.STONE, BLOCKS.WOOD, BLOCKS.LEAVES, BLOCKS.SAND, BLOCKS.JEB, BLOCKS.WWB, BLOCKS.FBB, BLOCKS.BENGALS, BLOCKS.SKYLINE];
                    const index = parseInt(e.code.slice(-1)) - 1;
                    if (index < blockTypes.length) {
                        selectedBlock = blockTypes[index];
                        updateHotbar();
                    }
                } else if (e.code === 'Digit0') {
                    const blockTypes = [BLOCKS.GRASS, BLOCKS.DIRT, BLOCKS.STONE, BLOCKS.WOOD, BLOCKS.LEAVES, BLOCKS.SAND, BLOCKS.JEB, BLOCKS.WWB, BLOCKS.FBB, BLOCKS.BENGALS, BLOCKS.SKYLINE];
                    if (blockTypes.length >= 10) {
                        selectedBlock = blockTypes[9]; // 0 = 10th item
                        updateHotbar();
                    }
                }

                // Q to place block, E to break block
                if (e.code === 'KeyQ') {
                    placeBlock();
                }
                if (e.code === 'KeyE') {
                    breakBlock();
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });

            // Scroll for block selection
            document.addEventListener('wheel', (e) => {
                if (!isPointerLocked) return;

                const blockTypes = [BLOCKS.GRASS, BLOCKS.DIRT, BLOCKS.STONE, BLOCKS.WOOD, BLOCKS.LEAVES, BLOCKS.SAND, BLOCKS.JEB, BLOCKS.WWB, BLOCKS.FBB, BLOCKS.BENGALS, BLOCKS.SKYLINE];
                let index = blockTypes.indexOf(selectedBlock);
                index += Math.sign(e.deltaY);
                if (index < 0) index = blockTypes.length - 1;
                if (index >= blockTypes.length) index = 0;
                selectedBlock = blockTypes[index];
                updateHotbar();
            });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Hotbar click/tap selection
            document.querySelectorAll('.hotbar-slot').forEach(slot => {
                slot.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectedBlock = parseInt(slot.dataset.block);
                    updateHotbar();
                });
            });
        }

        // Setup touch controls
        function setupTouchControls() {
            if (!isTouchDevice) return;

            document.body.classList.add('touch-device');
            document.getElementById('touch-controls').classList.add('active');

            // Update instructions for touch
            document.querySelectorAll('.desktop-only').forEach(el => el.style.display = 'none');
            document.querySelectorAll('.touch-only').forEach(el => el.style.display = 'block');

            const joystickZone = document.getElementById('joystick-zone');
            const joystickBase = document.getElementById('joystick-base');
            const joystickStick = document.getElementById('joystick-stick');
            const lookZone = document.getElementById('look-zone');
            const breakBtn = document.getElementById('break-btn');
            const placeBtn = document.getElementById('place-btn');
            const jumpBtn = document.getElementById('jump-btn');
            const pauseBtn = document.getElementById('pause-btn');

            // Pause button - shows instructions overlay
            pauseBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const instructions = document.getElementById('instructions');
                instructions.classList.toggle('hidden');
                touchActive = instructions.classList.contains('hidden');
            }, { passive: false });

            // Joystick touch handlers
            joystickZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (touchState.joystick.active) return;

                const touch = e.changedTouches[0];
                touchState.joystick.active = true;
                touchState.joystick.identifier = touch.identifier;
                touchState.joystick.startX = touch.clientX;
                touchState.joystick.startY = touch.clientY;
                touchState.joystick.currentX = touch.clientX;
                touchState.joystick.currentY = touch.clientY;

                // Position joystick at touch point
                joystickBase.style.left = (touch.clientX - 60) + 'px';
                joystickBase.style.top = (touch.clientY - 60) + 'px';
                joystickBase.style.display = 'block';

                joystickStick.style.left = touch.clientX + 'px';
                joystickStick.style.top = touch.clientY + 'px';
                joystickStick.style.display = 'block';

                // Dismiss instructions on first touch
                if (!touchActive) {
                    touchActive = true;
                    document.getElementById('instructions').classList.add('hidden');
                }
            }, { passive: false });

            joystickZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    if (touch.identifier === touchState.joystick.identifier) {
                        touchState.joystick.currentX = touch.clientX;
                        touchState.joystick.currentY = touch.clientY;

                        // Calculate delta from start
                        let dx = touch.clientX - touchState.joystick.startX;
                        let dy = touch.clientY - touchState.joystick.startY;

                        // Limit to max distance
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > JOYSTICK_MAX_DISTANCE) {
                            dx = (dx / dist) * JOYSTICK_MAX_DISTANCE;
                            dy = (dy / dist) * JOYSTICK_MAX_DISTANCE;
                        }

                        // Update stick position
                        joystickStick.style.left = (touchState.joystick.startX + dx) + 'px';
                        joystickStick.style.top = (touchState.joystick.startY + dy) + 'px';

                        // Normalize to -1 to 1
                        touchState.moveDirection.x = dx / JOYSTICK_MAX_DISTANCE;
                        touchState.moveDirection.z = dy / JOYSTICK_MAX_DISTANCE;
                    }
                }
            }, { passive: false });

            joystickZone.addEventListener('touchend', (e) => {
                for (const touch of e.changedTouches) {
                    if (touch.identifier === touchState.joystick.identifier) {
                        touchState.joystick.active = false;
                        touchState.joystick.identifier = null;
                        touchState.moveDirection.x = 0;
                        touchState.moveDirection.z = 0;

                        joystickBase.style.display = 'none';
                        joystickStick.style.display = 'none';
                    }
                }
            });

            joystickZone.addEventListener('touchcancel', (e) => {
                touchState.joystick.active = false;
                touchState.joystick.identifier = null;
                touchState.moveDirection.x = 0;
                touchState.moveDirection.z = 0;
                joystickBase.style.display = 'none';
                joystickStick.style.display = 'none';
            });

            // Look zone touch handlers
            lookZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (touchState.look.active) return;

                const touch = e.changedTouches[0];
                touchState.look.active = true;
                touchState.look.identifier = touch.identifier;
                touchState.look.lastX = touch.clientX;
                touchState.look.lastY = touch.clientY;

                // Dismiss instructions on first touch
                if (!touchActive) {
                    touchActive = true;
                    document.getElementById('instructions').classList.add('hidden');
                }
            }, { passive: false });

            lookZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    if (touch.identifier === touchState.look.identifier) {
                        const dx = touch.clientX - touchState.look.lastX;
                        const dy = touch.clientY - touchState.look.lastY;

                        player.rotation.y -= dx * TOUCH_SENSITIVITY;
                        player.rotation.x -= dy * TOUCH_SENSITIVITY;
                        player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.x));

                        touchState.look.lastX = touch.clientX;
                        touchState.look.lastY = touch.clientY;
                    }
                }
            }, { passive: false });

            lookZone.addEventListener('touchend', (e) => {
                for (const touch of e.changedTouches) {
                    if (touch.identifier === touchState.look.identifier) {
                        touchState.look.active = false;
                        touchState.look.identifier = null;
                    }
                }
            });

            lookZone.addEventListener('touchcancel', (e) => {
                touchState.look.active = false;
                touchState.look.identifier = null;
            });

            // Action buttons
            breakBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                breakBlock();
            }, { passive: false });

            placeBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                placeBlock();
            }, { passive: false });

            // Jump button
            jumpBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                touchState.jump = true;
            }, { passive: false });

            jumpBtn.addEventListener('touchend', (e) => {
                touchState.jump = false;
            });

            jumpBtn.addEventListener('touchcancel', (e) => {
                touchState.jump = false;
            });

            // Dismiss instructions on any touch outside controls
            document.addEventListener('touchstart', (e) => {
                if (!touchActive && e.target === renderer.domElement) {
                    touchActive = true;
                    document.getElementById('instructions').classList.add('hidden');
                }
            });
        }

        // Raycasting for block interaction
        function getRaycastHit() {
            const raycaster = new THREE.Raycaster();
            raycaster.far = 6;

            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyEuler(new THREE.Euler(player.rotation.x, player.rotation.y, 0, 'YXZ'));

            raycaster.set(camera.position, direction);

            const meshArray = Array.from(meshes.values());
            const intersects = raycaster.intersectObjects(meshArray);

            if (intersects.length > 0) {
                return intersects[0];
            }
            return null;
        }

        // Break block
        function breakBlock() {
            const hit = getRaycastHit();
            if (hit) {
                const { x, y, z } = hit.object.userData;
                setBlock(x, y, z, BLOCKS.AIR);
            }
        }

        // Place block
        function placeBlock() {
            const hit = getRaycastHit();
            if (hit) {
                const { x, y, z } = hit.object.userData;
                const normal = hit.face.normal;
                const newX = x + Math.round(normal.x);
                const newY = y + Math.round(normal.y);
                const newZ = z + Math.round(normal.z);

                // Don't place inside player
                const playerBox = new THREE.Box3(
                    new THREE.Vector3(player.position.x - 0.3, player.position.y - 1.6, player.position.z - 0.3),
                    new THREE.Vector3(player.position.x + 0.3, player.position.y + 0.2, player.position.z + 0.3)
                );
                const blockBox = new THREE.Box3(
                    new THREE.Vector3(newX, newY, newZ),
                    new THREE.Vector3(newX + 1, newY + 1, newZ + 1)
                );

                if (!playerBox.intersectsBox(blockBox)) {
                    setBlock(newX, newY, newZ, selectedBlock);
                }
            }
        }

        // Collision detection
        function checkCollision(x, y, z) {
            const playerWidth = 0.3;
            const playerHeight = 1.6;
            const epsilon = 0.001; // Small buffer to avoid floating point issues

            // Player bounding box (y is eye level, so feet are at y - playerHeight)
            // Add epsilon to minY to prevent detecting ground we're standing on
            const minX = x - playerWidth;
            const maxX = x + playerWidth;
            const minY = y - playerHeight + epsilon;
            const maxY = y + 0.1;
            const minZ = z - playerWidth;
            const maxZ = z + playerWidth;

            // Check all blocks that could intersect with player
            for (let bx = Math.floor(minX); bx <= Math.floor(maxX); bx++) {
                for (let by = Math.floor(minY); by <= Math.floor(maxY); by++) {
                    for (let bz = Math.floor(minZ); bz <= Math.floor(maxZ); bz++) {
                        if (getBlock(bx, by, bz) !== BLOCKS.AIR) {
                            // Check AABB intersection
                            if (maxX > bx && minX < bx + 1 &&
                                maxY > by && minY < by + 1 &&
                                maxZ > bz && minZ < bz + 1) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        // Update player physics
        function updatePlayer() {
            // Movement
            {
                const moveDirection = new THREE.Vector3();

                // Keyboard input
                if (keys['KeyW']) moveDirection.z -= 1;
                if (keys['KeyS']) moveDirection.z += 1;
                if (keys['KeyA']) moveDirection.x -= 1;
                if (keys['KeyD']) moveDirection.x += 1;

                // Touch joystick input
                if (isTouchDevice && touchState.joystick.active) {
                    moveDirection.x = touchState.moveDirection.x;
                    moveDirection.z = touchState.moveDirection.z;
                }

                moveDirection.normalize();
                moveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);

                // Apply movement
                const newX = player.position.x + moveDirection.x * MOVE_SPEED;
                const newZ = player.position.z + moveDirection.z * MOVE_SPEED;

                // X movement
                if (!checkCollision(newX, player.position.y, player.position.z)) {
                    player.position.x = newX;
                }

                // Z movement
                if (!checkCollision(player.position.x, player.position.y, newZ)) {
                    player.position.z = newZ;
                }
            }

            // Gravity with terminal velocity
            player.velocity.y += GRAVITY;
            player.velocity.y = Math.max(player.velocity.y, -0.5); // Terminal velocity

            // Jump (keyboard or touch)
            if ((keys['Space'] || touchState.jump) && player.onGround) {
                player.velocity.y = JUMP_FORCE;
                player.onGround = false;
            }

            // Y movement with ground detection
            const playerHeight = 1.6;
            const feetY = player.position.y - playerHeight;

            // Find ground level below player
            let groundY = -100;
            const px = Math.floor(player.position.x);
            const pz = Math.floor(player.position.z);
            for (let checkY = Math.floor(feetY) + 1; checkY >= 0; checkY--) {
                if (getBlock(px, checkY, pz) !== BLOCKS.AIR) {
                    groundY = checkY + 1; // Top of the block
                    break;
                }
            }

            const newY = player.position.y + player.velocity.y;
            const newFeetY = newY - playerHeight;

            // Check if we would go below ground
            if (newFeetY < groundY && player.velocity.y < 0) {
                player.position.y = groundY + playerHeight;
                player.velocity.y = 0;
                player.onGround = true;
            } else if (!checkCollision(player.position.x, newY, player.position.z)) {
                player.position.y = newY;
                player.onGround = false;
            } else {
                if (player.velocity.y < 0) {
                    player.onGround = true;
                }
                player.velocity.y = 0;
            }

            // Keep player in bounds
            player.position.x = Math.max(0.5, Math.min(WORLD_SIZE - 0.5, player.position.x));
            player.position.z = Math.max(0.5, Math.min(WORLD_SIZE - 0.5, player.position.z));

            // Prevent falling through world
            if (player.position.y < -10) {
                player.position.y = 30;
                player.velocity.y = 0;
            }

            // Update camera
            camera.position.copy(player.position);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = player.rotation.y;
            camera.rotation.x = player.rotation.x;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            updatePlayer();
            renderer.render(scene, camera);
        }

        // Start the game
        init();
    </script>
</body>
</html>
