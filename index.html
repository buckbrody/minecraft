<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Minecraft Clone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #87CEEB;
        }
        canvas {
            display: block;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            mix-blend-mode: difference;
        }
        #crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        #crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
        #hotbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            z-index: 100;
        }
        .hotbar-slot {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #555;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-family: monospace;
            font-size: 12px;
        }
        .hotbar-slot.selected {
            border-color: white;
            background: rgba(255, 255, 255, 0.3);
        }
        .block-preview {
            width: 36px;
            height: 36px;
            image-rendering: pixelated;
        }
        #instructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            font-family: Arial, sans-serif;
            z-index: 200;
        }
        #instructions h1 {
            margin-bottom: 20px;
            color: #4CAF50;
        }
        #instructions p {
            margin: 10px 0;
            line-height: 1.6;
        }
        #instructions .key {
            background: #333;
            padding: 2px 8px;
            border-radius: 3px;
            border: 1px solid #555;
        }
        #instructions.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="hotbar"></div>
    <div id="instructions">
        <h1>ðŸŽ® Minecraft Clone</h1>
        <p>Click to start playing</p>
        <p><span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span> - Move</p>
        <p><span class="key">Space</span> - Jump</p>
        <p><span class="key">Mouse</span> - Look around</p>
        <p><span class="key">E</span> or <span class="key">Left Click</span> - Break block</p>
        <p><span class="key">Q</span> or <span class="key">Right Click</span> - Place block</p>
        <p><span class="key">1-6</span> or <span class="key">Scroll</span> - Select block</p>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Block types
        const BLOCKS = {
            AIR: 0,
            GRASS: 1,
            DIRT: 2,
            STONE: 3,
            WOOD: 4,
            LEAVES: 5,
            SAND: 6
        };

        const BLOCK_COLORS = {
            [BLOCKS.GRASS]: { top: 0x7CFC00, side: 0x8B4513, bottom: 0x8B4513 },
            [BLOCKS.DIRT]: { top: 0x8B4513, side: 0x8B4513, bottom: 0x8B4513 },
            [BLOCKS.STONE]: { top: 0x808080, side: 0x808080, bottom: 0x808080 },
            [BLOCKS.WOOD]: { top: 0xDEB887, side: 0x8B4513, bottom: 0xDEB887 },
            [BLOCKS.LEAVES]: { top: 0x228B22, side: 0x228B22, bottom: 0x228B22 },
            [BLOCKS.SAND]: { top: 0xF4A460, side: 0xF4A460, bottom: 0xF4A460 }
        };

        const BLOCK_NAMES = {
            [BLOCKS.GRASS]: 'Grass',
            [BLOCKS.DIRT]: 'Dirt',
            [BLOCKS.STONE]: 'Stone',
            [BLOCKS.WOOD]: 'Wood',
            [BLOCKS.LEAVES]: 'Leaves',
            [BLOCKS.SAND]: 'Sand'
        };

        // World settings
        const WORLD_SIZE = 64;
        const WORLD_HEIGHT = 32;
        const CHUNK_SIZE = 16;

        // Game state
        let scene, camera, renderer;
        let world = new Map();
        let meshes = new Map();
        let selectedBlock = BLOCKS.GRASS;
        let isPointerLocked = false;

        // Player state
        const player = {
            position: new THREE.Vector3(WORLD_SIZE / 2, 20, WORLD_SIZE / 2),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: { x: 0, y: 0 },
            onGround: false
        };

        // Controls
        const keys = {};
        const GRAVITY = -0.015;
        const JUMP_FORCE = 0.25;
        const MOVE_SPEED = 0.12;
        const MOUSE_SENSITIVITY = 0.002;

        // Simplex noise implementation
        class SimplexNoise {
            constructor(seed = Math.random()) {
                this.p = new Uint8Array(256);
                for (let i = 0; i < 256; i++) this.p[i] = i;
                for (let i = 255; i > 0; i--) {
                    seed = (seed * 16807) % 2147483647;
                    const j = seed % (i + 1);
                    [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
                }
                this.perm = new Uint8Array(512);
                for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];
            }

            noise2D(x, y) {
                const F2 = 0.5 * (Math.sqrt(3) - 1);
                const G2 = (3 - Math.sqrt(3)) / 6;

                const s = (x + y) * F2;
                const i = Math.floor(x + s);
                const j = Math.floor(y + s);

                const t = (i + j) * G2;
                const X0 = i - t;
                const Y0 = j - t;
                const x0 = x - X0;
                const y0 = y - Y0;

                const i1 = x0 > y0 ? 1 : 0;
                const j1 = x0 > y0 ? 0 : 1;

                const x1 = x0 - i1 + G2;
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1 + 2 * G2;
                const y2 = y0 - 1 + 2 * G2;

                const ii = i & 255;
                const jj = j & 255;

                const grad = (hash, x, y) => {
                    const h = hash & 7;
                    const u = h < 4 ? x : y;
                    const v = h < 4 ? y : x;
                    return ((h & 1) ? -u : u) + ((h & 2) ? -2 * v : 2 * v);
                };

                let n0 = 0, n1 = 0, n2 = 0;
                let t0 = 0.5 - x0 * x0 - y0 * y0;
                if (t0 >= 0) {
                    t0 *= t0;
                    n0 = t0 * t0 * grad(this.perm[ii + this.perm[jj]], x0, y0);
                }

                let t1 = 0.5 - x1 * x1 - y1 * y1;
                if (t1 >= 0) {
                    t1 *= t1;
                    n1 = t1 * t1 * grad(this.perm[ii + i1 + this.perm[jj + j1]], x1, y1);
                }

                let t2 = 0.5 - x2 * x2 - y2 * y2;
                if (t2 >= 0) {
                    t2 *= t2;
                    n2 = t2 * t2 * grad(this.perm[ii + 1 + this.perm[jj + 1]], x2, y2);
                }

                return 70 * (n0 + n1 + n2);
            }
        }

        const noise = new SimplexNoise(12345);

        // Generate height at position
        function getHeight(x, z) {
            const scale1 = 0.02;
            const scale2 = 0.05;
            const scale3 = 0.1;

            const n1 = noise.noise2D(x * scale1, z * scale1) * 8;
            const n2 = noise.noise2D(x * scale2, z * scale2) * 4;
            const n3 = noise.noise2D(x * scale3, z * scale3) * 2;

            // Base height 12, ensure minimum of 4
            return Math.max(4, Math.floor(12 + n1 + n2 + n3));
        }

        // World management
        function getBlockKey(x, y, z) {
            return `${x},${y},${z}`;
        }

        function getBlock(x, y, z) {
            return world.get(getBlockKey(x, y, z)) || BLOCKS.AIR;
        }

        function setBlock(x, y, z, type) {
            const key = getBlockKey(x, y, z);
            if (type === BLOCKS.AIR) {
                world.delete(key);
                if (meshes.has(key)) {
                    scene.remove(meshes.get(key));
                    meshes.delete(key);
                }
            } else {
                world.set(key, type);
                createBlockMesh(x, y, z, type);
            }
            updateNeighborMeshes(x, y, z);
        }

        // Check if face is visible
        function isFaceVisible(x, y, z, dx, dy, dz) {
            return getBlock(x + dx, y + dy, z + dz) === BLOCKS.AIR;
        }

        // Create block mesh with only visible faces
        function createBlockMesh(x, y, z, type) {
            const key = getBlockKey(x, y, z);

            // Remove existing mesh
            if (meshes.has(key)) {
                scene.remove(meshes.get(key));
            }

            const colors = BLOCK_COLORS[type];
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const normals = [];
            const vertexColors = [];

            // Helper to add a face
            const addFace = (v1, v2, v3, v4, normal, color) => {
                vertices.push(...v1, ...v2, ...v3, ...v1, ...v3, ...v4);
                for (let i = 0; i < 6; i++) {
                    normals.push(...normal);
                    const c = new THREE.Color(color);
                    vertexColors.push(c.r, c.g, c.b);
                }
            };

            // Top face (+Y)
            if (isFaceVisible(x, y, z, 0, 1, 0)) {
                addFace(
                    [0, 1, 0], [0, 1, 1], [1, 1, 1], [1, 1, 0],
                    [0, 1, 0], colors.top
                );
            }

            // Bottom face (-Y)
            if (isFaceVisible(x, y, z, 0, -1, 0)) {
                addFace(
                    [0, 0, 1], [0, 0, 0], [1, 0, 0], [1, 0, 1],
                    [0, -1, 0], colors.bottom
                );
            }

            // Front face (+Z)
            if (isFaceVisible(x, y, z, 0, 0, 1)) {
                addFace(
                    [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1],
                    [0, 0, 1], colors.side
                );
            }

            // Back face (-Z)
            if (isFaceVisible(x, y, z, 0, 0, -1)) {
                addFace(
                    [1, 0, 0], [0, 0, 0], [0, 1, 0], [1, 1, 0],
                    [0, 0, -1], colors.side
                );
            }

            // Right face (+X)
            if (isFaceVisible(x, y, z, 1, 0, 0)) {
                addFace(
                    [1, 0, 1], [1, 0, 0], [1, 1, 0], [1, 1, 1],
                    [1, 0, 0], colors.side
                );
            }

            // Left face (-X)
            if (isFaceVisible(x, y, z, -1, 0, 0)) {
                addFace(
                    [0, 0, 0], [0, 0, 1], [0, 1, 1], [0, 1, 0],
                    [-1, 0, 0], colors.side
                );
            }

            if (vertices.length === 0) return;

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColors, 3));

            const material = new THREE.MeshLambertMaterial({
                vertexColors: true,
                transparent: type === BLOCKS.LEAVES,
                opacity: type === BLOCKS.LEAVES ? 0.9 : 1
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.userData = { x, y, z, type };

            scene.add(mesh);
            meshes.set(key, mesh);
        }

        // Update neighboring block meshes
        function updateNeighborMeshes(x, y, z) {
            const neighbors = [
                [x+1, y, z], [x-1, y, z],
                [x, y+1, z], [x, y-1, z],
                [x, y, z+1], [x, y, z-1]
            ];

            for (const [nx, ny, nz] of neighbors) {
                const type = getBlock(nx, ny, nz);
                if (type !== BLOCKS.AIR) {
                    createBlockMesh(nx, ny, nz, type);
                }
            }
        }

        // Generate terrain
        function generateWorld() {
            for (let x = 0; x < WORLD_SIZE; x++) {
                for (let z = 0; z < WORLD_SIZE; z++) {
                    const height = getHeight(x, z);

                    for (let y = 0; y < height; y++) {
                        let blockType;
                        if (y === height - 1) {
                            blockType = BLOCKS.GRASS;
                        } else if (y > height - 4) {
                            blockType = BLOCKS.DIRT;
                        } else {
                            blockType = BLOCKS.STONE;
                        }
                        world.set(getBlockKey(x, y, z), blockType);
                    }
                }
            }

            // Generate trees
            for (let i = 0; i < 50; i++) {
                const tx = Math.floor(Math.random() * (WORLD_SIZE - 4)) + 2;
                const tz = Math.floor(Math.random() * (WORLD_SIZE - 4)) + 2;
                const ty = getHeight(tx, tz);

                if (getBlock(tx, ty - 1, tz) === BLOCKS.GRASS) {
                    generateTree(tx, ty, tz);
                }
            }

            // Create all meshes
            for (const [key, type] of world) {
                const [x, y, z] = key.split(',').map(Number);
                createBlockMesh(x, y, z, type);
            }
        }

        // Generate a tree
        function generateTree(x, y, z) {
            const height = 4 + Math.floor(Math.random() * 3);

            // Trunk
            for (let i = 0; i < height; i++) {
                world.set(getBlockKey(x, y + i, z), BLOCKS.WOOD);
            }

            // Leaves
            const leafStart = y + height - 2;
            for (let dy = 0; dy < 3; dy++) {
                const radius = dy === 2 ? 1 : 2;
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dz = -radius; dz <= radius; dz++) {
                        if (dx === 0 && dz === 0 && dy < 2) continue;
                        if (Math.abs(dx) === 2 && Math.abs(dz) === 2) continue;
                        const key = getBlockKey(x + dx, leafStart + dy, z + dz);
                        if (!world.has(key)) {
                            world.set(key, BLOCKS.LEAVES);
                        }
                    }
                }
            }
        }

        // Initialize Three.js
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 30, 80);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(player.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            // Generate world
            generateWorld();

            // Set player position above terrain
            const spawnHeight = getHeight(Math.floor(player.position.x), Math.floor(player.position.z));
            player.position.y = spawnHeight + 2;

            // Create hotbar
            createHotbar();

            // Event listeners
            setupEventListeners();

            // Start game loop
            animate();
        }

        // Create hotbar UI
        function createHotbar() {
            const hotbar = document.getElementById('hotbar');
            const blockTypes = [BLOCKS.GRASS, BLOCKS.DIRT, BLOCKS.STONE, BLOCKS.WOOD, BLOCKS.LEAVES, BLOCKS.SAND];

            blockTypes.forEach((type, index) => {
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot' + (type === selectedBlock ? ' selected' : '');
                slot.dataset.block = type;

                const color = BLOCK_COLORS[type].top;
                slot.innerHTML = `
                    <div class="block-preview" style="background: #${color.toString(16).padStart(6, '0')}; border: 2px solid #${(color - 0x202020).toString(16).padStart(6, '0')}"></div>
                `;
                slot.title = `${BLOCK_NAMES[type]} (${index + 1})`;

                hotbar.appendChild(slot);
            });
        }

        // Update hotbar selection
        function updateHotbar() {
            document.querySelectorAll('.hotbar-slot').forEach(slot => {
                slot.classList.toggle('selected', parseInt(slot.dataset.block) === selectedBlock);
            });
        }

        // Setup event listeners
        function setupEventListeners() {
            // Pointer lock
            document.addEventListener('click', () => {
                if (!isPointerLocked) {
                    document.body.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === document.body;
                document.getElementById('instructions').classList.toggle('hidden', isPointerLocked);
            });

            // Mouse movement
            document.addEventListener('mousemove', (e) => {
                if (!isPointerLocked) return;

                player.rotation.y -= e.movementX * MOUSE_SENSITIVITY;
                player.rotation.x -= e.movementY * MOUSE_SENSITIVITY;
                player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.x));
            });

            // Mouse buttons
            document.addEventListener('mousedown', (e) => {
                if (!isPointerLocked) return;

                if (e.button === 0) {
                    breakBlock();
                } else if (e.button === 2) {
                    placeBlock();
                }
            });

            document.addEventListener('contextmenu', (e) => e.preventDefault());

            // Keyboard
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;

                // Number keys for block selection
                if (e.code >= 'Digit1' && e.code <= 'Digit6') {
                    const blockTypes = [BLOCKS.GRASS, BLOCKS.DIRT, BLOCKS.STONE, BLOCKS.WOOD, BLOCKS.LEAVES, BLOCKS.SAND];
                    selectedBlock = blockTypes[parseInt(e.code.slice(-1)) - 1];
                    updateHotbar();
                }

                // Q to place block, E to break block
                if (e.code === 'KeyQ') {
                    placeBlock();
                }
                if (e.code === 'KeyE') {
                    breakBlock();
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });

            // Scroll for block selection
            document.addEventListener('wheel', (e) => {
                if (!isPointerLocked) return;

                const blockTypes = [BLOCKS.GRASS, BLOCKS.DIRT, BLOCKS.STONE, BLOCKS.WOOD, BLOCKS.LEAVES, BLOCKS.SAND];
                let index = blockTypes.indexOf(selectedBlock);
                index += Math.sign(e.deltaY);
                if (index < 0) index = blockTypes.length - 1;
                if (index >= blockTypes.length) index = 0;
                selectedBlock = blockTypes[index];
                updateHotbar();
            });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // Raycasting for block interaction
        function getRaycastHit() {
            const raycaster = new THREE.Raycaster();
            raycaster.far = 6;

            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyEuler(new THREE.Euler(player.rotation.x, player.rotation.y, 0, 'YXZ'));

            raycaster.set(camera.position, direction);

            const meshArray = Array.from(meshes.values());
            const intersects = raycaster.intersectObjects(meshArray);

            if (intersects.length > 0) {
                return intersects[0];
            }
            return null;
        }

        // Break block
        function breakBlock() {
            const hit = getRaycastHit();
            if (hit) {
                const { x, y, z } = hit.object.userData;
                setBlock(x, y, z, BLOCKS.AIR);
            }
        }

        // Place block
        function placeBlock() {
            const hit = getRaycastHit();
            if (hit) {
                const { x, y, z } = hit.object.userData;
                const normal = hit.face.normal;
                const newX = x + Math.round(normal.x);
                const newY = y + Math.round(normal.y);
                const newZ = z + Math.round(normal.z);

                // Don't place inside player
                const playerBox = new THREE.Box3(
                    new THREE.Vector3(player.position.x - 0.3, player.position.y - 1.6, player.position.z - 0.3),
                    new THREE.Vector3(player.position.x + 0.3, player.position.y + 0.2, player.position.z + 0.3)
                );
                const blockBox = new THREE.Box3(
                    new THREE.Vector3(newX, newY, newZ),
                    new THREE.Vector3(newX + 1, newY + 1, newZ + 1)
                );

                if (!playerBox.intersectsBox(blockBox)) {
                    setBlock(newX, newY, newZ, selectedBlock);
                }
            }
        }

        // Collision detection
        function checkCollision(x, y, z) {
            const playerWidth = 0.3;
            const playerHeight = 1.6;
            const epsilon = 0.001; // Small buffer to avoid floating point issues

            // Player bounding box (y is eye level, so feet are at y - playerHeight)
            // Add epsilon to minY to prevent detecting ground we're standing on
            const minX = x - playerWidth;
            const maxX = x + playerWidth;
            const minY = y - playerHeight + epsilon;
            const maxY = y + 0.1;
            const minZ = z - playerWidth;
            const maxZ = z + playerWidth;

            // Check all blocks that could intersect with player
            for (let bx = Math.floor(minX); bx <= Math.floor(maxX); bx++) {
                for (let by = Math.floor(minY); by <= Math.floor(maxY); by++) {
                    for (let bz = Math.floor(minZ); bz <= Math.floor(maxZ); bz++) {
                        if (getBlock(bx, by, bz) !== BLOCKS.AIR) {
                            // Check AABB intersection
                            if (maxX > bx && minX < bx + 1 &&
                                maxY > by && minY < by + 1 &&
                                maxZ > bz && minZ < bz + 1) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        // Update player physics
        function updatePlayer() {
            // Movement
            {
                const moveDirection = new THREE.Vector3();

                if (keys['KeyW']) moveDirection.z -= 1;
                if (keys['KeyS']) moveDirection.z += 1;
                if (keys['KeyA']) moveDirection.x -= 1;
                if (keys['KeyD']) moveDirection.x += 1;

                moveDirection.normalize();
                moveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);

                // Apply movement
                const newX = player.position.x + moveDirection.x * MOVE_SPEED;
                const newZ = player.position.z + moveDirection.z * MOVE_SPEED;

                // X movement
                if (!checkCollision(newX, player.position.y, player.position.z)) {
                    player.position.x = newX;
                }

                // Z movement
                if (!checkCollision(player.position.x, player.position.y, newZ)) {
                    player.position.z = newZ;
                }
            }

            // Gravity with terminal velocity
            player.velocity.y += GRAVITY;
            player.velocity.y = Math.max(player.velocity.y, -0.5); // Terminal velocity

            // Jump
            if (keys['Space'] && player.onGround) {
                player.velocity.y = JUMP_FORCE;
                player.onGround = false;
            }

            // Y movement with ground detection
            const playerHeight = 1.6;
            const feetY = player.position.y - playerHeight;

            // Find ground level below player
            let groundY = -100;
            const px = Math.floor(player.position.x);
            const pz = Math.floor(player.position.z);
            for (let checkY = Math.floor(feetY) + 1; checkY >= 0; checkY--) {
                if (getBlock(px, checkY, pz) !== BLOCKS.AIR) {
                    groundY = checkY + 1; // Top of the block
                    break;
                }
            }

            const newY = player.position.y + player.velocity.y;
            const newFeetY = newY - playerHeight;

            // Check if we would go below ground
            if (newFeetY < groundY && player.velocity.y < 0) {
                player.position.y = groundY + playerHeight;
                player.velocity.y = 0;
                player.onGround = true;
            } else if (!checkCollision(player.position.x, newY, player.position.z)) {
                player.position.y = newY;
                player.onGround = false;
            } else {
                if (player.velocity.y < 0) {
                    player.onGround = true;
                }
                player.velocity.y = 0;
            }

            // Keep player in bounds
            player.position.x = Math.max(0.5, Math.min(WORLD_SIZE - 0.5, player.position.x));
            player.position.z = Math.max(0.5, Math.min(WORLD_SIZE - 0.5, player.position.z));

            // Prevent falling through world
            if (player.position.y < -10) {
                player.position.y = 30;
                player.velocity.y = 0;
            }

            // Update camera
            camera.position.copy(player.position);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = player.rotation.y;
            camera.rotation.x = player.rotation.x;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            updatePlayer();
            renderer.render(scene, camera);
        }

        // Start the game
        init();
    </script>
</body>
</html>
